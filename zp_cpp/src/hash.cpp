#include "zp_cpp/hash.hpp"

#include <openssl/evp.h>

#include "zp_cpp/dbg.hpp"

#include <cstring>
#include <string>

using namespace zp;
using namespace zp::hash;

// =========================================================================================================================================
// =========================================================================================================================================
// hash_value: Computes std::hash-compatible value using FNV-1a on hash256 bytes for use in unordered containers.
// =========================================================================================================================================
// =========================================================================================================================================
std::size_t hash::hash_value(const hash256& h) noexcept
{
    const std::uint64_t fnv_offset = 1469598103934665603ull;
    const std::uint64_t fnv_prime  = 1099511628211ull;

    std::uint64_t acc              = fnv_offset;
    for (size_t i = 0; i < 32; ++i)
    {
        acc ^= static_cast<unsigned char>(h.bytes[i]);
        acc *= fnv_prime;
    }
    return static_cast<std::size_t>(acc);
}

// =========================================================================================================================================
// =========================================================================================================================================
// hash_data: Computes SHA-256 hash of raw data buffer using OpenSSL. Returns zeroed hash on failure.
// =========================================================================================================================================
// =========================================================================================================================================
hash256 hash::hash_data(const void* data, std::uint64_t size) noexcept
{
    hash256 out         = {};

    unsigned int md_len = 0;
    unsigned char* dst  = reinterpret_cast<unsigned char*>(out.bytes);

    const int ok        = EVP_Digest(data, static_cast<size_t>(size), dst, &md_len, EVP_sha256(), nullptr);

    if (ok != 1 || md_len != 32)
    {
        ERR("failed hash");
        std::memset(out.bytes, 0, sizeof(out.bytes));
    }

    return out;
}

// =========================================================================================================================================
// =========================================================================================================================================
// hash_data: Computes SHA-256 hash of span<const std::byte> by delegating to void* overload.
// =========================================================================================================================================
// =========================================================================================================================================
hash256 hash::hash_data(zp::span<const std::byte> data) noexcept
{
    return hash_data(static_cast<const void*>(data.p), static_cast<std::uint64_t>(data.count));
}

// =========================================================================================================================================
// =========================================================================================================================================
// to_str: Converts hash256 to lowercase hexadecimal string representation (64 characters).
// =========================================================================================================================================
// =========================================================================================================================================
std::string hash::to_str(const hash256& h)
{
    static constexpr char HEX[] = "0123456789abcdef";
    std::string s;
    s.resize(64);
    for (size_t i = 0; i < 32; ++i)
    {
        unsigned char b = static_cast<unsigned char>(h.bytes[i]);
        s[2 * i]        = HEX[(b >> 4) & 0xF];
        s[2 * i + 1]    = HEX[b & 0xF];
    }
    return s;
}

// =========================================================================================================================================
// =========================================================================================================================================
// operator==: Compares two hash256 values for byte-wise equality.
// =========================================================================================================================================
// =========================================================================================================================================
bool hash::operator==(const hash256& a, const hash256& b) noexcept
{
    return std::memcmp(a.bytes, b.bytes, sizeof(a.bytes)) == 0;
}

// =========================================================================================================================================
// =========================================================================================================================================
// operator!=: Compares two hash256 values for byte-wise inequality.
// =========================================================================================================================================
// =========================================================================================================================================
bool hash::operator!=(const hash256& a, const hash256& b) noexcept
{
    return !operator==(a, b);
}

// =========================================================================================================================================
// =========================================================================================================================================
// std::hash specialization: Forwards to zp::hash::hash_value.
// =========================================================================================================================================
// =========================================================================================================================================
size_t std::hash<zp::hash::hash256>::operator()(const zp::hash::hash256& h) const noexcept
{
    return zp::hash::hash_value(h);
}
