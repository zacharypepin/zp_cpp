#include <gtest/gtest.h>
#include "zp_cpp/core.hpp"
#include "zp_cpp/hash.hpp"
#include "zp_cpp/buff.hpp"
#include <cstring>

// =========================================================================================================================================
// =========================================================================================================================================
// HashDataBasic: Validates hash_data() produces deterministic SHA-256 hashes.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, HashDataBasic)
{
    const char* data = "hello world";
    auto hash1       = zp::hash::hash_data(data, std::strlen(data));
    auto hash2       = zp::hash::hash_data(data, std::strlen(data));

    EXPECT_TRUE(hash1 == hash2);
}

// =========================================================================================================================================
// =========================================================================================================================================
// HashDataDifferent: Validates different inputs produce different hashes.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, HashDataDifferent)
{
    const char* data1 = "hello";
    const char* data2 = "world";

    auto hash1        = zp::hash::hash_data(data1, std::strlen(data1));
    auto hash2        = zp::hash::hash_data(data2, std::strlen(data2));

    EXPECT_FALSE(hash1 == hash2);
    EXPECT_TRUE(hash1 != hash2);
}

// =========================================================================================================================================
// =========================================================================================================================================
// HashSpan: Validates hash_data() works with span<const std::byte> input.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, HashSpan)
{
    const char* data = "test data";
    std::byte bytes[9];
    std::memcpy(bytes, data, 9);

    zp::span<const std::byte> span{bytes, 9};
    auto hash  = zp::hash::hash_data(span);

    auto hash2 = zp::hash::hash_data(span);
    EXPECT_TRUE(hash == hash2);
}

// =========================================================================================================================================
// =========================================================================================================================================
// ToStringFormat: Validates to_str() produces 64-character lowercase hex string.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, ToStringFormat)
{
    const char* data     = "test";
    auto hash            = zp::hash::hash_data(data, 4);
    std::string hash_str = zp::hash::to_str(hash);

    EXPECT_EQ(hash_str.length(), 64);

    for (char c : hash_str)
    {
        EXPECT_TRUE((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f'));
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// HashEquality: Validates hash256 equality and inequality operators.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, HashEquality)
{
    zp::hash::hash256 hash1 = zp::hash::hash_data("test", 4);
    zp::hash::hash256 hash2 = zp::hash::hash_data("test", 4);
    zp::hash::hash256 hash3 = zp::hash::hash_data("different", 9);

    EXPECT_TRUE(hash1 == hash2);
    EXPECT_FALSE(hash1 == hash3);
    EXPECT_TRUE(hash1 != hash3);
}

// =========================================================================================================================================
// =========================================================================================================================================
// HashValueForUnorderedMap: Validates hash_value() produces consistent hash codes.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, HashValueForUnorderedMap)
{
    zp::hash::hash256 hash = zp::hash::hash_data("test", 4);
    std::size_t hv1        = zp::hash::hash_value(hash);
    std::size_t hv2        = zp::hash::hash_value(hash);

    EXPECT_EQ(hv1, hv2);
}

// =========================================================================================================================================
// =========================================================================================================================================
// StdHashSpecialization: Validates std::hash specialization works for hash256.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(HashTest, StdHashSpecialization)
{
    std::hash<zp::hash::hash256> hasher;
    zp::hash::hash256 hash     = zp::hash::hash_data("test", 4);

    const std::size_t expected = zp::hash::hash_value(hash);
    EXPECT_EQ(hasher(hash), expected);
}
