#include <gtest/gtest.h>
#include "zp_cpp/core.hpp"
#include "zp_cpp/buff.hpp"

// =========================================================================================================================================
// =========================================================================================================================================
// BasicCreation: Validates span construction with pointer and count.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, BasicCreation)
{
    int data[] = {1, 2, 3, 4, 5};
    zp::span<int> span{data, 5};

    EXPECT_EQ(span.p, data);
    EXPECT_EQ(span.count, 5);
}

// =========================================================================================================================================
// =========================================================================================================================================
// Iterators: Validates span begin/end iterators work with range-based for loops.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, Iterators)
{
    int data[] = {1, 2, 3, 4, 5};
    zp::span<int> span{data, 5};

    EXPECT_EQ(span.begin(), data);
    EXPECT_EQ(span.end(), data + 5);

    int sum = 0;
    for (auto val : span)
    {
        sum += val;
    }
    EXPECT_EQ(sum, 15);
}

// =========================================================================================================================================
// =========================================================================================================================================
// ConstIterators: Validates const span iterators work correctly.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, ConstIterators)
{
    int data[] = {1, 2, 3};
    const zp::span<int> span{data, 3};

    EXPECT_EQ(span.cbegin(), data);
    EXPECT_EQ(span.cend(), data + 3);
}

// =========================================================================================================================================
// =========================================================================================================================================
// Equality: Validates span equality operator compares by value and size.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, Equality)
{
    int data1[] = {1, 2, 3};
    int data2[] = {1, 2, 3};
    int data3[] = {1, 2, 4};

    zp::span<int> span1{data1, 3};
    zp::span<int> span2{data2, 3};
    zp::span<int> span3{data3, 3};
    zp::span<int> span4{data1, 2};

    EXPECT_TRUE(span1 == span2);
    EXPECT_FALSE(span1 == span3);
    EXPECT_FALSE(span1 == span4);
}

// =========================================================================================================================================
// =========================================================================================================================================
// SplitMethod: Validates span.split() creates two subspans at given size boundary with bounds checking.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, SplitMethod)
{
    int data[] = {1, 2, 3, 4, 5};
    zp::span<int> span{data, 5};
    zp::span<int> first, second;

    EXPECT_EQ(span.split(2, &first, &second), zp::Result::ZC_SUCCESS);
    EXPECT_EQ(first.p, data);
    EXPECT_EQ(first.count, 2);
    EXPECT_EQ(second.p, data + 2);
    EXPECT_EQ(second.count, 3);

    EXPECT_EQ(span.split(5, &first, &second), zp::Result::ZC_SUCCESS);
    EXPECT_EQ(first.p, data);
    EXPECT_EQ(first.count, 5);
    EXPECT_EQ(second.p, data + 5);
    EXPECT_EQ(second.count, 0);

    EXPECT_EQ(span.split(6, &first, &second), zp::Result::ZC_OUT_OF_BOUNDS);
}

// =========================================================================================================================================
// =========================================================================================================================================
// CopyMethod: Validates span.cpy() copies data to destination with bounds checking.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, CopyMethod)
{
    int data[] = {10, 20, 30, 40, 50};
    zp::span<int> span{data, 5};
    int dest[3];

    EXPECT_EQ(span.cpy(1, 3, dest), zp::Result::ZC_SUCCESS);
    EXPECT_EQ(dest[0], 20);
    EXPECT_EQ(dest[1], 30);
    EXPECT_EQ(dest[2], 40);

    EXPECT_EQ(span.cpy(6, 1, dest), zp::Result::ZC_OUT_OF_BOUNDS);
    EXPECT_EQ(span.cpy(3, 5, dest), zp::Result::ZC_OUT_OF_BOUNDS);
}

// =========================================================================================================================================
// =========================================================================================================================================
// ReceiveMethod: Validates span.rcv() receives data from source with bounds checking.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, ReceiveMethod)
{
    int data[5] = {1, 2, 3, 4, 5};
    zp::span<int> span{data, 5};
    int src[] = {99, 88, 77};

    EXPECT_EQ(span.rcv(1, 3, src), zp::Result::ZC_SUCCESS);
    EXPECT_EQ(data[0], 1);
    EXPECT_EQ(data[1], 99);
    EXPECT_EQ(data[2], 88);
    EXPECT_EQ(data[3], 77);
    EXPECT_EQ(data[4], 5);

    EXPECT_EQ(span.rcv(6, 1, src), zp::Result::ZC_OUT_OF_BOUNDS);
    EXPECT_EQ(span.rcv(3, 5, src), zp::Result::ZC_OUT_OF_BOUNDS);
}

// =========================================================================================================================================
// =========================================================================================================================================
// ToStringConversion: Validates to_str() converts span bytes to space-separated string.
// =========================================================================================================================================
// =========================================================================================================================================
TEST(SpanTest, ToStringConversion)
{
    std::byte data[] = {std::byte{10}, std::byte{20}, std::byte{30}};
    zp::span<std::byte> span{data, 3};

    std::string result = zp::to_str(span);
    EXPECT_EQ(result, "10 20 30");
}
